# حل مسئله‌ی n-وزیر با استفاده از سه الگوریتم: Backtracking، الگوریتم ژنتیک، و CSP-MAC

## هدف پروژه

در این پروژه، هدف ما مقایسه‌ی سه الگوریتم مختلف برای حل مسئله‌ی کلاسیک **n-Queen** است. ما بررسی کردیم که کدام‌یک از این الگوریتم‌ها از نظر **سرعت، دقت، و بهینگی** عملکرد بهتری دارند.

---

## 1. الگوریتم Backtracking

### مکانیزم اجرا:
- وزیر اول در سطر اول قرار می‌گیرد.
- سپس در هر سطر بعدی، سعی می‌شود وزیری قرار داده شود که با وزیرهای قبلی برخورد نداشته باشد (در ستون، قطر اصلی و قطر فرعی).
- در صورت برخورد، به عقب برمی‌گردد (Backtrack) و موقعیت قبلی را تغییر می‌دهد.

### بهینه‌سازی‌های اعمال‌شده:
- استفاده از **آرایه‌های کمکی** برای بررسی سریع‌تر برخوردها.
- پیاده‌سازی **Fail Fast**: بازگشت سریع در صورت اولین برخورد.
- جستجوی **ردیف به ردیف** با state کوچک‌تر.
- **عدم ساخت دوباره ماتریس** در هر مرحله.

### نتیجه:
- تا اندازه‌ی 30 وزیر بسیار سریع عمل می‌کند.
- با افزایش اندازه، زمان حل به‌صورت نمایی افزایش می‌یابد.

---

## 2. الگوریتم ژنتیک (Genetic Algorithm)

### مکانیزم اجرا:
- نمایش کروموزوم: آرایه‌ای که موقعیت هر وزیر در ستون را مشخص می‌کند.
- تابع برازندگی (Fitness): تعداد برخوردها بین وزیرها.
- انتخاب (Selection): انتخاب جواب‌های بهتر برای تولید نسل جدید.
- ترکیب (Crossover) و جهش (Mutation): تولید تنوع در نسل‌های بعد.

### مشکلات اولیه:
- سرعت بسیار پایین.
- عدم توانایی تشخیص جواب نادرست.
- عملکرد ضعیف روی CPU.

### بهینه‌سازی‌های اعمال‌شده:
- **افزودن اعلام خطا** هنگام برخورد.
- **استفاده از GPU** برای اجرای موازی با کمک کتابخانه‌ی `torch` (نسخه‌ی Python 3.11).
- **موازی‌سازی با Multi-threading** برای ارزیابی هم‌زمان جمعیت.
- بهینه‌سازی توابع انتخاب، کراس‌اوور و جهش برای جلوگیری از گیر افتادن در مینیمم محلی.

### نتیجه:
- الگوریتم تا 100 وزیر را سریع حل می‌کند.
- برای 150 وزیر هم قابل‌قبول است.
- بهترین عملکرد از نظر **سرعت و مقیاس‌پذیری**.

---

## 3. الگوریتم CSP-MAC

### مکانیزم اجرا:
- متغیرها: ستون‌های صفحه.
- دامنه‌ها: ردیف‌های ممکن.
- قیدها: عدم برخورد در ردیف و قطرها.
- استفاده از تکنیک **MAC (Maintaining Arc Consistency)** برای حذف مقادیر ناسازگار از دامنه‌ها.

### بهینه‌سازی‌های اعمال‌شده:
- استفاده از **Arc Consistency** برای کاهش فضای جستجو.
- **مدیریت یال‌ها با صف** برای بازبینی فقط متغیرهای وابسته.
- استفاده از **MRV** برای انتخاب متغیر با کمترین دامنه.
- بررسی فقط دامنه‌ی فعلی متغیرهای مرتبط.

### نتیجه:
- حل بسیار دقیق و بدون خطا.
- سرعت کم، حتی با بهینه‌سازی.

---

## گرافیک صفحه‌ی نمایش وزیرها

- پیاده‌سازی شده با **کتابخانه‌ی Tkinter**.
- هر خانه با `tk.Label` و رنگ شطرنجی (سفید-قهوه‌ای) ساخته شده.
- علامت وزیر به صورت گرافیکی و قرمز مشخص می‌شود.
- استفاده از `grid()` برای چیدمان دقیق و خودکار.

### تغییر اندازه‌ی صفحه:
برای نمایش بهتر در حالت‌های مختلف:

```python
cell_size = 25 if n <= 20 else (15 if n <= 50 else 8)
font_size = cell_size - 10 if cell_size > 10 else 6
