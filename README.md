# پروژه حل مساله n وزیر با استفاده از 3 الگوریتم

هدف ما مقایسه‌ی این 3 الگوریتم است. می‌خواهیم ببینیم کدام یک توانایی حل مسأله دقیق‌تر و سریع‌تر و بهینه‌تر را دارند.

---

## Backtracking

### مکانیزم کار این الگوریتم:
وزیر اول را در سطر اول و یکی از ستون‌ها قرار می‌دهد. سپس به سراغ سطر دوم می‌رود و تلاش می‌کند وزیری در آن سطر قرار دهد که با وزیر قبلی تضاد نداشته باشد. اگر تضادی نبود، ادامه می‌دهد تا همه وزیرها چیده شوند.

### مشکلات اولیه:
ابتدا که این الگوریتم را پیاده کردم سرعت بسیار پایینی داشت.

### روش‌های بهینه‌سازی:
- استفاده از آرایه‌های کمکی برای بررسی سریع برخوردها
- ترتیب جستجوی بهینه (ردیف به ردیف)
- برگشت سریع‌تر در صورت برخورد (Fail Fast) با return False
- استفاده از الگوریتم بازگشتی با state کوچک‌تر
- جلوگیری از ساخت دوباره ماتریس صفحه

### نتیجه:
سرعت بسیار بیشتر شد. تا 30 وزیر را برایم به سرعت حل می‌کند. بالاتر از آن طول می‌کشد.

---

## ژنتیک

### مکانیزم کار این الگوریتم:
- نمایش کروموزوم: هر جواب احتمالی (چیدمان وزیرها) یک کروموزوم است.
- تابع برازندگی (Fitness Function): شمارش تعداد برخوردها بین وزیرها.
- انتخاب (Selection): جواب‌های بهتر شانس بیشتری برای تولید مثل دارند.
- ترکیب (Crossover): دو جواب خوب با هم ترکیب می‌شوند تا فرزند جدید تولید کنند.
- جهش (Mutation): برخی عناصر جواب تغییر تصادفی پیدا می‌کنند برای تنوع جمعیت.

این فرایند در نسل‌های متعدد تکرار می‌شود تا زمانی که یک جواب بدون برخورد یافت شود یا تعداد مشخصی نسل تمام شود.

### مشکلات اولیه:
- سرعت کمی داشت
- تعداد زیادی از ورودی‌ها را اشتباه تحویل می‌داد بدون اینکه اعلام کند اشتباه است

### اقدامات بهینه‌سازی:
- ابتدا مشکل فهمیدن اشتباه را حل کردم
- استفاده از نسخه‌ی GPU-accelerated برای محاسبات موازی با `torch`
- نصب نسخه 3.11 پایتون چون نسخه 3.12 پشتیبانی لازم را نداشت
- موازی‌سازی: پردازش نسل‌ها و ارزیابی جمعیت به صورت همزمان در چند نخ یا فرآیند
- بهینه‌سازی توابع (طراحی مناسب کروموزوم‌ها، الگوریتم‌های انتخاب، کراس‌اوور و جهش)

### نتیجه:
- سرعت حل مساله بسیار زیاد شد و کار بر روی GPU افتاد
- تا 100 وزیر را به سرعت و تا 150 وزیر را به صورت معقول حل می‌کرد

---

## الگوریتم CSP-MAC

### مکانیزم:
- متغیرها: هر ستون از صفحه یک متغیر است.
- دامنه‌ها: مقدارهایی که هر متغیر می‌تواند بگیرد (ردیف‌های 0 تا N-1)
- قیدها: هیچ‌کدام از وزیرها نباید در یک ردیف یا قطر باشند.
- MAC: بعد از هر انتساب مقدار به یک متغیر، الگوریتم بلافاصله بقیه دامنه‌ها را بررسی می‌کند تا ناسازگاری‌ها را حذف کند (با استفاده از Arc Consistency)

### مشکلات اولیه:
بدون خطا عمل می‌کرد ولی سرعت وحشتناک پایینی داشت.

### اقدامات بهینه‌سازی:
- استفاده از آرک کانسیستنسی به جای چک کردن کامل تمام مقادیر
- استفاده از صف برای مدیریت Constraints
- MRV: انتخاب متغیر با دامنه‌ی کمتر
- بررسی فقط دامنه‌ی فعلی متغیرهای همسایه به جای تمام مقادیر

### نتیجه:
تغییرات تا حدی توانست سرعت را افزایش دهد، اما ذات این الگوریتم کم‌سرعت است، هرچند بسیار دقیق است.

---

## گرافیک پروژه

- از کتابخانه Tkinter استفاده شده است.
- هر خانه‌ی صفحه شطرنجی یک `tk.Label` است.
  - رنگ پس‌زمینه خانه‌ها به صورت متناوب انتخاب می‌شود (`#f0d9b5` و `#b58863`) تا حالت شطرنجی ایجاد شود.
  - علامت وزیر و رنگ قرمز روی خانه قرار می‌گیرد.
- با استفاده از `grid()` خانه‌ها کنار هم چیده می‌شوند تا ساختار جدول حفظ شود.

### تنظیم خودکار اندازه صفحه:

```python
cell_size = 25 if n <= 20 else (15 if n <= 50 else 8)
font_size = cell_size - 10 if cell_size > 10 else 6
