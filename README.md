پروژه  حل مساله   n وزیر  با استفاده از 3 الگوریتم backtracking و ژنتیک و csp- mac .
هدف ما مقایسه ی این 3 الگوریتم است. میخواهیم ببینیم کدام یک توانایی حل مسله دقیق تر و سریع تر و بهینه تر را دارند.
Backtracking : 
مکانیزم کار این الگوریتم : وزیر اول را در سطر اول و یکی از ستون‌ها قرار می‌دهد. سپس به سراغ سطر دوم می‌رود و تلاش می‌کند وزیری در آن سطر قرار دهد که با وزیر قبلی تضاد نداشته باشد. اگر تضادی نبود، ادامه می‌دهد تا همه وزیرها چیده شوند. اگر تضادی نبود، ادامه می‌دهد تا همه وزیرها چیده شوند. اگر تضادی نبود، ادامه می‌دهد تا همه وزیرها چیده شوند.

ابتدا که این الگوریتم را پیاده کردم سرعت بسیار پایینی داشت سعی کردم ان  را  بهینه کنم با استفاده از روش های (استفاده از آرایه‌های کمکی برای بررسی سریع برخوردها / رتیب جستجوی بهینه (ردیف به ردیف) / برگشت سریع‌تر در صورت برخورد (Fail Fast) با return False / استفاده از الگوریتم بازگشتی با state کوچک‌تر / جلوگیری از ساخت دوباره ماتریس صفحه)

هنگامی که این اعمال را پیاده سازی کردم سرعت بسیار بیشتر شد. تا 30 وزیر را برایم به سرعت حل میکند.
بالاتر از ان طول میکشد.

ژنتیک : 
 مکانیزم کار این الگوریتم : نمایش کروموزوم: هر جواب احتمالی (چیدمان وزیرها) یک کروموزوم است، معمولاً یک لیست از N عدد که نشان می‌دهد در هر ستون، وزیر در کدام سطر است. تابع برازندگی (Fitness Function): شمارش تعداد برخوردها بین وزیرها. جواب خوب برخورد کم دارد. تابع برازندگی (Fitness Function): شمارش تعداد برخوردها بین وزیرها. جواب خوب برخورد کم دارد.
انتخاب (Selection): جواب‌های بهتر شانس بیشتری برای تولید مثل دارند. ترکیب (Crossover): دو جواب خوب با هم ترکیب می‌شوند تا فرزند جدید تولید کنند. جهش (Mutation): برخی عناصر جواب تغییر تصادفی پیدا می‌کنند برای تنوع جمعیت.
این فرایند در نسل‌های متعدد تکرار می‌شود تا زمانی که یک جواب بدون برخورد یافت شود یا تعداد مشخصی نسل تمام شود.

ابتدا که این الگوریتم را پیاده سازی کردم بسیار سرعت کمی داشت همچنین تعداد زیادی از ورودی هارا اشتباه تحویل میداد بدون اینکه حتی اعلام کنه اشتباه حل کرده.
پس رفتم سراغ بهینه کردن ان 
ابتدا مشکل فهمیدن اشتباه را حل کردم
سپس برای حل مشکل سرعت به مشکلات زیادی بر خورد کردم. این الگوریتم اصلا خوب روی سیستم و cpu  ران نمیشد و خیلی طولش میداد به طوری که برای 20 وزیر با مدت زیادی صبر میکردم.
پس از روش های سنتی معماری کامپیوتر استفاده کردم.
با استفاده از نسخه‌ی GPU-accelerated ، محاسبات تکراری و سنگین به صورت موازی روی کارت گرافیک انجام شد که به طور قابل توجهی زمان اجرا را کاهش داد. از انجایی که نسخه 3.12  ان را پشتیبانی نمیکرد نسخه ی 3.11   را برای این کار نصب کردم. و پشتیبانی صورت گرفت . سپس با استفاده از کتابخانه ی tourch    با استفاده از تکنیک های یادگیری عمیق
سرعت حل مساله بسیار زیاد شد و کار بر روی GPU افتاد.
سپس از موازی سازی استفاده کردم . پردازش نسل‌ها و ارزیابی جمعیت به صورت همزمان در چند نخ  یا فرآیند اجرا شد که موجب استفاده بهتر از منابع سیستم می‌شود.
سپس به سراغ بهینه کردن توابع رفتم (طراحی مناسب کروموزوم‌ها و کاهش فضای جستجو / استفاده از الگوریتم‌های انتخاب، کراس‌اوور و جهش بهینه‌تر برای حفظ تنوع جمعیت و جلوگیری از افتادن در مینیمم‌های محلی)

با این اعمال الگوریتم ژنتیک بسیار قدرتمند تر شد و سریع تر به طوری که تا ورودی 100 وزیر را به سرعت و تا 150 وزیر را به صورت معقول حل میکرد.

الگوریتم csp_mac  :
مکانیزم کار این الگوریتم : متغیرها: هر ستون از صفحه یک متغیر است. دامنه‌ها: مقدارهایی که هر متغیر می‌تواند بگیرد (ردیف‌های 0 تا N-1). قیدها: هیچ‌کدام از وزیرها نباید در یک ردیف یا قطر باشند. MAC: بعد از هر انتساب مقدار به یک متغیر، الگوریتم بلافاصله بقیه دامنه‌ها را بررسی می‌کند تا ناسازگاری‌ها را حذف کند (با استفاده از Arc Consistency).
با هر انتخاب، دامنه‌ها کوچک‌تر می‌شوند و احتمال برخورد کمتر می‌شود.

خب این الگوریتم را وقتی پیاده سازی کردم بدون خطا عمل میکرد اصلا ندیدم مساله را اشتباه حل کنه اما سرعت وحشتنتک پایینی داشت 
سعی کردم ان را بهینه سازی کنم  با استفاده از روش های :
آرک کانسِیستنسی (Arc Consistency) به جای چک کردن کامل تمام مقادیر: به جای اینکه هر بار تمام مقادیر ممکن برای هر متغیر را بررسی کنیم، با حفظ آرک کانسِیستنسی در هر مرحله، دامنه متغیرها را محدود کردیم. این کار باعث کاهش تعداد مقادیری می‌شود که باید برای هر متغیر امتحان شود و به کاهش فضای جستجو کمک می‌کند.
استفاده از صف  برای مدیریت Constraints : برای حفظ آرک کانسِیستنسی، تمامی  Constraintsرا در یک صف قرار داده و هر بار که دامنه یک متغیر تغییر می‌کند، یال‌های مرتبط را دوباره به صف اضافه می‌کنیم. این روش باعث می‌شود فقط متغیرهای متاثر از تغییرات بررسی شوند، نه همه متغیرها.
MRV : هنگام جستجوی بازگشتی برای اختصاص مقدار به متغیرها، متغیری را انتخاب می‌کنیم که دامنه‌ی کمتری دارد. این استراتژی باعث می‌شود زودتر به بن‌بست برسیم و از انجام کارهای بی‌فایده جلوگیری شود.
 و در نهایت به جای مقایسه با تمام مقادیر ممکن، فقط مقادیر دامنه فعلی متغیرهای همسایه بررسی می‌شود که بار محاسباتی را کاهش می‌دهد.
این تغییرات تا حدی توانست سرعت را افزایش دهد اما در نهایت خیلی زیاد نبود ذات این الگوریتم کم سرعت است اما دقیق.

برای صفحه ی نمایش گرافیکی وزیر ها : 
از کتابخانه Tkinter استفاده شده است.
هر خانه صفحه شطرنجی یک tk.Label است که: رنگ پس‌زمینه خانه‌ها به صورت متناوب انتخاب می‌شود (#f0d9b5 و #b58863) تا حالت شطرنجی ایجاد شود. علامت وزیر و رنگ قرمز روی خانه قرار می‌گیرد.
با استفاده از grid خانه‌ها کنار هم چیده می‌شوند که ساختار جدول را به صورت خودکار حفظ کند.


وقتی تعداد وزیر زیاد می‌شود، اگر سلول‌ها و فونت ثابت باشند:
سلول‌ها خیلی بزرگ می‌شوند و کل صفحه خارج از اندازه پنجره قرار می‌گیرد. یا خیلی کوچک شود و وزیرها دیده نشوند.
برای حل این مشکل، پروژه مکانیزمی تعریف کرده:

cell_size = 25 if n <= 20 else (15 if n <= 50 else 8)
font_size = cell_size - 10 if cell_size > 10 else 6

در نهایت برای مقایسه بین این 3 الگوریتم با توجه به بهینه سازی های صورت گرفته 
الگوریتم ژنتیک از بقیه برای این بازی کار امد تر است.
